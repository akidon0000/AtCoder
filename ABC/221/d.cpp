#include <bits/stdc++.h>
using namespace std;
using ll = long long int;
using ld = long double;

template<typename T> using v = vector<T>;
template<typename T> using vv = vector<vector<T>>;
template<typename T> using vvv = vector<vector<vector<T>>>;
template<typename T> inline void errv(T& v) { for (auto x: v) cerr << x << " "; cerr << endl; }
inline void errv(vector<bool>& v) { for (auto x: v) cerr << (x ? 1 : 0) << " "; cerr << endl; }
template<typename T> inline void dbgn(string n, T x) { cerr << n << ": " << x << endl; }
template<typename T> inline void dbgn(string n, vector<T>& v) { cerr << n << ": "; errv(v); }
template<typename T> inline void dbgn(string n, vector<vector<T>>& m) { cerr << n << ":" << endl; for (auto& v: m) errv(v); }

#define _GLIBCXX_DEBUG
#define rep(i, n) for (ll i = 0; i < (n); ++i)
#define repp(i, c, n) for (ll i = c; i < (n); ++i)
#define repa(i, a) for (auto i: a)
#define all(a) (a).begin(),(a).end()
#define rall(a) (a).rbegin(),(a).rend()
#define so(v) sort((v).begin(), (v).end())
#define rso(v) sort((v).rbegin(), (v).rend())
#define len(x) ll((x).size())

//p(出力) d(デバッグ *多次元配列も可能*)
#define p(x) cout << x << endl;
#define d(x) dbgn(#x, x);

const ll INF = 1LL << 60;  //無限大
const ll MOD = 1000000007; //10^9 + 7

struct input {
    template <class T> operator T() {
        T t;
        std::cin >> t;
        return t;
    }
};

void solve(long long N, std::vector<long long> A, std::vector<long long> B) {
    std::map<long long, long long> up;
    std::map<long long, long long> down;

    for (unsigned int i = 0; i < N; i++) {
        long long start = A[i];
        long long end = A[i] + B[i];
        if (up.count(start) == 0) {
            up.insert(std::make_pair(start, 1));
        } else {
            up[start]++;
        }
        if (down.count(end) == 0) {
            down.insert(std::make_pair(end, 1));
        } else {
            down[end]++;
        }
    }

    std::vector<long long> answers(N + 1, 0);

    auto u = up.begin();
    auto d = down.begin();
    int current = 0;
    int prev_day = 0;

    while (u != up.end() || d != down.end()) {
        if (u == up.end()) {
            long long current_day = d->first;
            long long duration = current_day - prev_day;
            prev_day = current_day;
            answers[current] += duration;
            current -= d->second;
            d++;
            continue;
        }
        if (d == down.end()) {
            long long current_day = u->first;
            long long duration = current_day - prev_day;
            prev_day = current_day;
            answers[current] += duration;
            current += u->second;
            u++;
            continue;
        }

        long long up_day = u->first;
        long long down_day = d->first;
        if (up_day == down_day) {
            long long duration = up_day - prev_day;
            prev_day = up_day;
            answers[current] += duration;
            current += u->second - d->second;
            u++;
            d++;
        } else if (up_day < down_day) {
            long long duration = up_day - prev_day;
            prev_day = up_day;
            answers[current] += duration;
            current += u->second;
            u++;
        } else {
            long long duration = down_day - prev_day;
            prev_day = down_day;
            answers[current] += duration;
            current -= d->second;
            d++;
        }
    }

    for (unsigned int i = 0; i < N; i++) {
        std::cout << (i != 0 ? " " : "") << answers[i + 1];
    }
    std::cout << std::endl;
}

// Generated by 2.5.0 https://github.com/kyuridenamida/atcoder-tools
int main() {
    long long N;
    N = input();
    std::vector<long long> A(N);
    std::vector<long long> B(N);
    for(int i = 0 ; i < N ; i++){
        A[i] = input();
        B[i] = input();
    }
    solve(N, std::move(A), std::move(B));
    return 0;
}
